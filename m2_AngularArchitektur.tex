\section{Angular Architektur}
Wie bereits erwähnt unterscheidet sich Angular zu anderen Bibliotheken in seiner Vielfalt und seinen Möglichkeiten, die das umfangreiche Framework mit sich bringt. Neben diversen Angular optimierten Benutzeroberflächen-Bibliotheken gibt es noch weitere Vorteile welche für die Verwendung von Angular sprechen.
\subsection{Komponenten}
Eine Angular Komponente basiert auf dem MVC (Model-View-Controller)\cite{ModelViewController} Modell.
\begin{figure}[H] \centering \includegraphics{MVC.png} \caption{Model View Controller} \end{figure}
Das Ziel von dem MVC-Modell ist die Trennung von Datenverarbeitung, Benutzeroberfläche und der Verbindung beider. Daraus resultiert eine erhöhte Flexibilität, welche Änderungen erleichtert. Die jeweiligen Bereiche sind, aufgrund der dynamischen Verbindung, unabhängig voneinander bearbeitbar. Dies verbessert zudem die Übersichtlichkeit.
\subsubsection{Modell}
Das Modell-Objekt enthält die Daten, die verarbeitet werden, sprich die Funktionalität und Logik der Komponente. Das Modell ist unabhängig von der Darstellung der Oberfläche (View) und wird separat nochmals in Units unterteilt.
Model = Anwendung ohne Benutzeroberfläche
\subsubsection{View}
Das View-Objekt ist für die optische Darstellung des Modell-Objektes zuständig. Das jeweilige Modell kann jedoch ebenfalls in verschiedenen Views verwendet werden. Dies reduziert Redundanzen und erhöht zugleih die Übersichtlichkeit.
\subsubsection{Controller}
Das Controller-Objekt ist verantwortlich für die Steuerung der Komponente, ebenso ermöglicht er die Steuerung durch die Benutzeroberfläche. Es verbindet das Modell-Objekt und das View-Objekte logisch miteinander und kommuniziert zwischen jenen mithilfe eines implementierten Frameworks. Alle Änderungen auf Seiten des Modells oder des View-Objektes, welches das jeweils andere Objekt betreffen, werden zuerst an den Controller, dort passend verarbeitet und dann richtig formatiert an das jeweils andere Objekt verschickt.

Wird in Angular eine Komponente mittels der Angular-CLI generiert, so bekommt man ein Verzeichnis mit dem Namen der Komponente und in dem Verzeichnis eine Typescript, eine HTML und eine SCSS Datei. Das Typescript-File repräsentiert das Modell-Objekt und die HTML und CSS Dateien das View-Objekt. Die Aufgaben des Controller-Objektes werden praktischerweise direkt von Angular selbst übernommen. Beim wechseln der Ansicht in der Applikation werden von Angular dynamisch Komponenten im DOM erstellt, verändert und gelöscht. Dies hat zur Folge das im DOM immer nur das angezeigt wird, was gerade zu sehen ist und der Inhalt erst dann geladen wird, wenn er benötigt wird.  Mit der Angular-CLI kann eine Komponente mithilfe des Befehls \codeword{ng generate component [name der Komponente]} erstellt werden.
\begin{figure}[H] \centering \includegraphics{Komponente.png} \caption{Snippet einer Komponente im Typescript} \end{figure}
Die "@Component" Annotation deklariert die TypeScript Datei als eine Komponente. Diese Komponente verlangt verschiedene Konfigurationsoptionen. Die meisten sind optional, einige wenige jedoch verpflichtend.
\paragraph{selector}
Ein CSS-Selektor der Angular die Anweisung gibt die dazugehörige Komponente zu erstellen und diesen CSS-Selektor im DOM platziert, ein kongretes Beispiel:\\ \codeword{<app-hero-list>HeroListComponent</app-hero-list>}
\paragraph{templateUrl}
Ein Pfad, der auf die dementsprechende HTML Datei verweist, welche den View Teil von MVC übernimmt. Alternativ kann auch ganzer HTML Code in templateUrl eingefügt werden.
\paragraph{providers}
Ein Array von Providern von Services, die in der Komponente benötigt und verwendet werden. In dem Beispiel wird der HeroService der Komponente zur Verfügung gestellt. Sämtliche Service-Attribute sind von nun an in der Komponente verfügbar.\cite{Component}
\subsection{Dateneinbindung (Data-Binding)}
Ohne ein Framework müsste man die Daten mittels Event-Handler statisch in das HTML hineinschreiben. Meistens resultiert dies in vielen Fehlermeldungen und einer unübersichtlichen Codierung. Zusätzlich werden die Daten nicht dynamisch weitergegeben, sondern sind von gewissen Events abhängig weshalb die Applikation alles andere als flüssig wäre.
Angular unterstützt "two-way data binding", ein Mechanisms der den View Part mit dem Model Part verbindet
\begin{figure}[H] \centering \includegraphics{Binding.png} \caption{Two Way Data Binding} \end{figure}
\subsection{Service und Dependency Injection}
Daten und logische Strukturen, die nicht einer einzelnen Komponente zugeordnet werden, sondern öffentlich in der Applikation für mehrere Einzelkomponenten zur Verfügung stehen müssen, werden in selbstgeschriebenen Serviceklassen strukturiert. Ein Service kann mittels der Angular CLI mit dem Befehl \codeword{ng generate service [name des Service]} erstellt werden. Jeder Service ist mit der Annotation "@Injectable()" deklariert. Diese Deklaration sorgt dafür, dass auf den Service über eine Dependency-Injection, die im Konstruktor der Klasse stattfindet, global zugegriffen werden kann.

Services halten die Codearchitektur strukturiert und übersichtlich. Vor allem Zugriffe auf Rest-APIs, sollten sowohl aus Effizienzgründen, da Services Serveranfragen schneller verarbeiten als Komponenten, als auch aus Komfortgründen, da man diese öfters als einmal verwenden muss, in den Service geschrieben werden. Neben selbstgeschriebenen Services gibt es natürlich noch Angular eigene Services, unter anderem der "http Service", der für Rest-API Zugriffe benötigt wird.
\subsection{Routing}
Das Angular Routing\cite{RouterAndNavigation} NgModule stellt einen Service zu Verfügung der das wechseln zwischen mehreren Seiten so einfach wie noch nie gestaltet, ohne dabei das DOM komplett neuladen zu müssen. Es wird lediglich die einzelne Komponente mit einer anderen Komponente ausgetauscht, dies geschieht innerhalb von Millisekunden, sodass ein Nutzer niemals etwas davon mitbekommt und somit ein flüssiges Nutzererlebniss garantiert wird. Beim Erstellen der Applikation mittels der Angular-CLI empfiehlt sich das Routing Module bereits zu beginn anzuhängen. Der Befehl lautet \codeword{ng new [name der Applikation] –-routing}, der eine app-routing.module.ts datei mitliefert die wie folgt aussieht.
\begin{figure}[H] \centering \includegraphics{Routing.png} \caption{Snippet der ThreeSixFive Routing Datei} \end{figure}
Zu sehen ist ein grober Ausschnitt des Navigationsbaumes der mittels einem URL Unterverzeichnis (Pfad), und der dazugehörigen Komponente definiert ist. Im HTML wird die Angular Komponente <router outlet> aufgerufen der die höchstgelegensten Pfade in sich kombiniert. Sollte in einer dieser Komponenten der Pfade der <router-outlet> wieder aufgerufen werden, beispielsweise wie in der MainApplicationComponent, so greift der <router-outlet> auf die Kinder Pfade zu.

Nun gibt es genau 3 verschiedene Möglichkeiten wie man zwischen den einzelnen Komponenten navigieren kann. Die einfachste Methode wäre dies mittels des Pfades über die Browserzeile zu tun. Nicht besonders userfreundlich. Eine weitere wäre die neue Komponente im HTML über einen Anker zu verlinken. Dies funktioniert über das routerLink Attribut der im Anker gesetzt wird, dem der neue Pfad übergeben wird. Die letzte Möglichkeit ist es dies über Typescript zu erledigen, was die Möglichkeit eines dynamischen Pagewechsel bietet und mit gewissen Eventhandlern interagieren lässt \codeword{(this.router.navigate[(‚/nameDesPfades‘)]);}
\subsection{HTTP-Client}
Die wenigsten Front-End Applikationen kommunizieren mit dem Back End nicht über das http Protokoll. Der http-Client\cite{HttpClient} in Angular bietet eine simple HTTP API die auf dem XMLHttpRequest Interface basiert. Zusätzlich verfügt das HTTP Client Module über Testfeatures, typisierte Requests und Objekte als Response. Nachdem das HTTP Client Module in app.module.ts initialisiert wurde, kann es in jeder Klasse, genauso wie jedes andere Module, verwendet werden. ThreeSixFive es in den meisten fällen mit JSON Files als Responses zu tun.
\subsection{Angular Change Detection}
Die Hauptaufgabe von Change-Detection\cite{AngularChangeDetectionExplained} ist es Änderungen in der Logik zu erkennen und diese im DOM dynamisch anzupassen um den User ein dynamisch reibungsloses Interneterlebnis zu bieten ohne dabei auf jegliche Event Trigger angewiesen zu sein. Diese Änderungen im DOM können als neue Paragraphen, Formularinhalte, Links, oder Butttons vorkommen. Grob gesagt bekommt man einen TypeScript Input der dich dynamisch anhand von zuvor definierten HTML Template Richtlinien als HTML Output wider spiegelt.

Kompliziert wird es erst dann, wenn Änderungen während der Laufzeit stattfinden, nachdem das DOM bereits gerendert wurde. Wie findet man heraus was in der Logik geändert wurde und wo man es dementsprechend im DOM anpassen zu müssen. In die DOM-Struktur einzugreifen ist immer aufwendig, nicht nur weil immer herausgefunden werden muss wann Änderungen auftreten, sondern auch weil man aus Leistungsgründen diese DOM-Eingriffe so gering wie möglich halten wollen.
Es gibt verschiedene Möglichkeiten die Webdynamik einer Applikation beizubehalten. Die wohl einfachste und unsauberste Variante wäre es bei jeder kleinen Änderung einen neuen http Request zu schicken und die Seite neu zu laden. Dies hat den offensichtlichen Nachteil, dass aufgrund kleiner Änderungen der Nutzer in seinem Nutzererlebniss um mehrere Sekunden behindert wird, abgesehen davon macht es keinen professionellen Eindruck, wenn man jedes Mal die Seite neu laden muss um Änderungen anzeigen zu können. Eine weitere Methode wäre die des Virtual-DOMs welches bei React.js und Vue.js angewandt wird.
Es gibt drei verschiedene Szenarien in der das DOM aktualisiert werden muss.

\begin{itemize}
\item Events (click, submit, hover, etc.)
\item	XHR (Daten die von einem Server geliefert werden)
\item	Timers (setTimeout, setIntervall, etc.)
\end{itemize}
Alle 3 Szenarien sind asynchron was zu dem Entschluss führt, dass bei jeder asynchronen Tätigkeit der Logikzustand sich möglichweise geändert hat und deshalb eine neue Abfrage nach der Logik erfolgen muss, das heißt Angular muss die View updaten.

Die Frage ist jetzt woher Angular die Information bekommt, das eine Änderung in der Logik erfolgte und infolgedessen das eine Aktualisierung erfolgen muss. Dies erfolgt über die Angular eigene Klasse „ApplicationRef“ in der eine Angular eigene Zone mit dem Namen ngZones und die Funktion „tick()“ verwendet wird.
\begin{figure}[H] \centering \includegraphics{ChangeDetection.png} \caption{Snippet der ApplicationRef KLasse} \end{figure}
Bei jeder Änderung wird die Funktion „tick()“ ausgeführt, die eine Change-Detection performt und die Logik und somit auch das DOM aktualisiert.
Jede Komponente besitzt ihre eigene Change-Detection. Das ist wichtig, da dies erlaubt gezielt nur die Komponenten zu aktualisieren, die auch eine Änderung erfahren haben. Wenn im Komponentenverzeichnis ein Event ausgelöst wird, wird im ApplicationRef Klasse \codeword{this.zone.run()} ausgeführt was zu einer  Change-Detection resultiert. Da eine komplexe Anwendung meistens aus mehreren Komponentenverzeichnissen besteht, und jede Komponente eine eigene Change-Detection besitzt, resultiert dies in einem komplexen Change-Detection Verzeichnis, in dem viele voneinander abhängige Änderung ineinanderfließen. Die Daten, und somit die veränderte Logik, wird von der höchstgelegensten Komponente bis hinunter zum tiefst gelegensten Kindernelement ebenfalls weitergegeben. Dies liegt daran, dass Change-Detection immer ganz oben im Komponentenverzeichnis anfängt und sich danach hinunter zur nächsten Komponente hinarbeitet. Dies lässt sich in solch einer Ausprägung in keinem anderen Framework wiederfinden und bietet unzählige Möglichkeiten der dynamischen Datenaktualisierung, sofern die Komponenten richtig strukturiert ineinander verschachtelt und mit passsenden Ein- und Ausgängen versehen sind.

Obwohl man ständig während der Applikationslaufzeit nach möglichen DOM-Änderungen, aufgrund Änderungen in der Logik, abfragen müssen, wirkt sich dies kaum auf die Angular Performance aus. Angular ist auf seine Change-Detection perfekt optimiert und handelt diese Vorgänge innerhalb weniger Millisekunden.
Angular generiert dynamisch während der Laufzeit Change-Detector Klassen für jede Komponente, welche perfekt an ihre Komponenten angepasst werden um die bestmöglichste Effizienz zu gewährleisten.
